---
title: "백준 5622번 : 다이얼"
date: "2021/11/17 16:47"
tag: "#백준알고리즘#javascript"
thumbnail: null
---

## #문제

상근이의 할머니는 아래 그림과 같이 오래된 다이얼 전화기를 사용한다.

![다이얼 이미지](../../../../post-images/20211117/5622.jpg)

전화를 걸고 싶은 번호가 있다면, 숫자를 하나를 누른 다음에 금속 핀이 있는 곳 까지 시계방향으로 돌려야 한다. 숫자를 하나 누르면 다이얼이 처음 위치로 돌아가고, 다음 숫자를 누르려면 다이얼을 처음 위치에서 다시 돌려야 한다.

숫자 1을 걸려면 총 2초가 필요하다. 1보다 큰 수를 거는데 걸리는 시간은 이보다 더 걸리며, 한 칸 옆에 있는 숫자를 걸기 위해선 1초씩 더 걸린다.

상근이의 할머니는 전화 번호를 각 숫자에 해당하는 문자로 외운다. 즉, 어떤 단어를 걸 때, 각 알파벳에 해당하는 숫자를 걸면 된다. 예를 들어, UNUCIC는 868242와 같다.

할머니가 외운 단어가 주어졌을 때, 이 전화를 걸기 위해서 필요한 최소 시간을 구하는 프로그램을 작성하시오.

<br/>

## #입력

첫째 줄에 알파벳 대문자로 이루어진 단어가 주어진다. 단어의 길이는 2보다 크거나 같고, 15보다 작거나 같다.

<br/>

## #출력

첫째 줄에 다이얼을 걸기 위해서 필요한 최소 시간을 출력한다.

<br/>

## #예제 입/출력

 input :
> WA

 output :
>  13

<br/>

 input :
> UNUCIC

 output :
>  36

<br/>

## #풀이

각 영어 단어마다 정해진 숫자가 있고, 해당 숫자를 걸기 위해서 필요한 시간도 이미 정해져 있는 값이다. 굳이 규칙을 찾아도 괜찮지만, 이런 경우에는 단순 대입이 더 쉽고 간단하다.

해당 알파벳이 어디에 있는지를 저장할 변수를 만들어야 한다. 어차피 알파벳 순서대로 배열에 저장해도 괜찮지만, 입력을 단어로 받기 때문에 배열을 사용하면 해당 문자열을 자르고, 몇번째 알파벳인지 구하는 번거로움이 발생한다.

이럴 때에는 객체를 사용하면 보다 빠르게 접근할 수 있다.

```javascript
let time = {
    a: 2, b: 2, c: 2,
    d: 3, e: 3, f: 3,
    g: 4, h: 4, i: 4,
    j: 5, k: 5, l: 5,
    m: 6, n: 6, o: 6,
    p: 7, q: 7, r: 7, s: 7,
    t: 8, u: 8, v: 8,
    w: 9, x: 9, y: 9, z: 9
};
```

이렇게 time 객체를 선언하면, time['a'] 이런식으로 접근할 수 있기 때문에 입력받은 문자열을 쪼갠 후에 한번 순회만 하면 끝이다~@

자 그럼 이제 걸리는 시간을 계산해 보자.

1을 걸려면 총 2초, 1보타 큰 수를 거는데 걸리는 시간은 1칸 증가할 때 마다 1초씩 증가. 즉,

> 1 + 번호 = 걸리는 시간

이런 식을 구할 수 있다. 자 그럼 이제 답을 구할 시간. reduce를 사용해도 좋고, forEach, for 아무거나 편한 방법으로 입력받은 문자열을 순회하면 된다. 나는 for 문이 가장 편해서 이걸로 사용했다.

```javascript
function solution(data) {
    let sp = data.toLowerCase().split('');
    let time = {
        a: 2, b: 2, c: 2,
        d: 3, e: 3, f: 3,
        g: 4, h: 4, i: 4,
        j: 5, k: 5, l: 5,
        m: 6, n: 6, o: 6,
        p: 7, q: 7, r: 7, s: 7,
        t: 8, u: 8, v: 8,
        w: 9, x: 9, y: 9, z: 9
    };


    let result = 0;
    for (let i = 0; i < sp.length; i++) {
        result += 1 + time[sp[i]];
    }

    console.log(result);
}


const input = require('fs').readFileSync('/dev/stdin').toString().trim();

solution(input);
```

규칙에 사로잡혀 돌아가기 쉬운 문제...케이스가 작고 정해져 있는 경우에는 이런 단순대입이 큰 힘을 발휘한다