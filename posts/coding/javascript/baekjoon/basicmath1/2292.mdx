---
title: "백준 2292번 : 벌집"
date: "2021/10/18 18:50"
tag:
    - 백준알고리즘
    - javascript
thumbnail: null
---

## #문제

![img](../../../../post-images/20211018/벌집.png)

위의 그림과 같이 육각형으로 이루어진 벌집이 있다. 그림에서 보는 바와 같이 중앙의 방 1부터 시작해서 이웃하는 방에 돌아가면서 1씩 증가하는 번호를 주소로 매길 수 있다.

숫자 N이 주어졌을 때, 벌집의 중앙 1에서 N번 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나가는지(시작과 끝을 포함하여)를 계산하는 프로그램을 작성하시오. 예를 들면, 13까지는 3개, 58까지는 5개를 지난다.

<br/>
<br/>

## #입력

첫째 줄에 N(1 ≤ N ≤ 1,000,000,000)이 주어진다.

<br/>
<br/>

## #출력

입력으로 주어진 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나는지 출력한다.

<br/>
<br/>

## #예제 입/출력

- input: 13
    output: 3
    
<br/>
<br/>

## #풀이

이런 문제들은 보통 일정한 규칙(패턴)들을 가지고 있는게 일반적이다. 그러지 않으면.....이후 한~~참 뒤의 항을 직접 계산하는 비효율적인 구조가 나타나기 때문이다.

이 문제도 보면, 1이 벌집 모양의 중심에 있고, 그 주위를 2~7까지의 총 6개의 숫자가 둘러싸고 있다. 그 다음에는 각 면당 1개씩 증가한 12개의 숫자들이 둘러싸고 있는 모습이다. 즉, 1개의 층을 지날 때 마다 이전 층의 숫자의 개수보다 6개가 증가한 숫자들이 둘러싸고 있는 모습이다. 

그 다음은, 해당 숫자까지의 최단거리를 구해야 한다. 벌집 모양의 재미있는 점이 숫자 N이 어느 방향, 어느 위치에 상관없이 각 층마다 1개의 숫자만 지나면 도달할 수 있다. 즉, 해당 숫자와 1 사이에 있는 층의 개수가 이번에 우리가 구할 정답이 된다. 이를 코드로 작성해보자!

<br/>

우리가 구할 숫자 n보다 커지기 전까지, 6 * 층의 개수 만큼 계속 더하면 된다. 
```javascript
function getLayer(n) {
    let layer = 1, i = 1;

    while(i < n) {
        i += 6 * layer;
        layer++;
    }

    console.log(layer);
}
```

이렇게 간단히 층의 개수를 구할 수 있다. 이후에는 입력값을 읽을 부분만 추가해주면 끝!

이번 문제도 규칙만 알면 간단히 풀 수 있는 문제였다. 규칙은 1개의 층 사이에 숫자의 개수 차이는 6. 이를 이용하여 우리가 구할 숫자 n의 층을 구하면 끝이였다. 항상 어렵게 생각하지 말고, 눈에 보이는 직관적인 정보들을 정리하다 보면 그 정보들 사이에서 연관성이 나오고, 문제 해결로 연결되는 것 같다.