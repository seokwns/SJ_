---
title: "백준 2447번 : 별 찍기 - 10"
date: "2022/2/28 21:03"
tag:
    - 백준알고리즘
    - javascript
thumbnail: null
---

## #문제

재귀적인 패턴으로 별을 찍어 보자. N이 3의 거듭제곱(3, 9, 27, ...)이라고 할 때, 크기 N의 패턴은 N×N 정사각형 모양이다.

크기 3의 패턴은 가운데에 공백이 있고, 가운데를 제외한 모든 칸에 별이 하나씩 있는 패턴이다.

> \*\*\*
> \*  \*
> \*\*\*

N이 3보다 클 경우, 크기 N의 패턴은 공백으로 채워진 가운데의 (N/3)×(N/3) 정사각형을 크기 N/3의 패턴으로 둘러싼 형태이다. 예를 들어 크기 27의 패턴은 예제 출력 1과 같다.

<br/>

## #입력

첫째 줄에 N이 주어진다. N은 3의 거듭제곱이다. 즉 어떤 정수 k에 대해 N=3k이며, 이때 1 ≤ k < 8이다.

<br/>

## #출력

첫째 줄부터 N번째 줄까지 별을 출력한다.

<br/>

## #예제 입/출력

```javascript
//예제입력 : 27
***************************
* ** ** ** ** ** ** ** ** *
***************************
***   ******   ******   ***
* *   * ** *   * ** *   * *
***   ******   ******   ***
***************************
* ** ** ** ** ** ** ** ** *
***************************
*********         *********
* ** ** *         * ** ** *
*********         *********
***   ***         ***   ***
* *   * *         * *   * *
***   ***         ***   ***
*********         *********
* ** ** *         * ** ** *
*********         *********
***************************
* ** ** ** ** ** ** ** ** *
***************************
***   ******   ******   ***
* *   * ** *   * ** *   * *
***   ******   ******   ***
***************************
* ** ** ** ** ** ** ** ** *
***************************
```

<br/>

## #풀이

드디어 문제같은 문제가 나왔다!

이것도 많이 본 문제지만....앞전에 나온 것들보단 아닌듯

자 생각을 해보자.

기본적으로 3*3 패턴이 반복되는데, 가운데에는 공백이 들어가야 한다.

크기가 3보다 커지는 경우에도 마찬가지로 크기를 3으로 나눈 크기의 패턴을 넣었다 비웠다 넣었다를 반복하는 과정

고로

> 가로,세로 for문을 길이 3씩 돌릴건데, 가운데 값일 경우에는 패턴을 반복하지 않고 그 외의 경우에만 패턴을 반복하는 형태이다.

자 이걸 코드로 작성해보자.

data에서 크기 N을 입력받았다. 그리고 패턴을 담을 배열 dots를 만들어준다.

dots 배열은 가로X세로 길이가 각각 N이 되도록 초기화해주자.

```javascript
function solution(data) {
    const n = parseInt(data);
    const dots = new Array(n);

    for (let i = 0; i < n; i++) {
        dots[i] = new Array(n);
    }
}
```

자 다음은 dots 배열을 채워야 하는데, 같은 행동을 계속해서 반복하는 과정이므로 재귀함수 하나를 만드는게 가장 간단할 것 같다.

크기 N에서 반복되는 패턴은 N / 3 패턴이 반복되므로 재취호출할 함수에 들어갈 크기는 N / 3이 되어야 한다. 그리고 좌표를 살펴보자.

for문으로 0부터 3까지 총 3번 반복한다고 할 때, 가로와 세로의 가운데에서는 공백이여야 하므로 함수가 호출되어서는 안된다. 나머지의 경우에만, 앞서 구한 크기로 패턴을 반복해야 한다.

자 위 과정을 계속 반복하다가, 길이가 1이 되는 순간에는 비로소 *이 나타날 것이다.

```javascript
function star(arr, x, y, len) {
    if (len == 1) {
        arr[x][y] = '*';
    }
    else {
        const _len = len / 3;

        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                if ( i != 1 || j != 1 ) {
                    star(arr, x + (_len * i), y + (_len * j), _len );
                }
            }
        }
    }
}
```

끝! 이제 출력만 하면 끝이다.

```javascript
function star(arr, x, y, len) {
    if (len == 1) {
        arr[x][y] = '*';
    }
    else {
        const _len = len / 3;

        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                if ( i != 1 || j != 1 ) {
                    star(arr, x + (_len * i), y + (_len * j), _len );
                }
            }
        }
    }
}


function solution(data) {
    const n = parseInt(data);
    const dots = new Array(n);

    for (let i = 0; i < n; i++) {
        dots[i] = new Array(n);
    }

    star(dots, 0, 0, n);
    let str = '';

    for (let x = 0; x < n; x++) {
        for (let y = 0; y < n; y++) {
            if (dots[x][y] == undefined) str += ' ';
            else str += dots[x][y];
        }
        str += '\n';
    }

    console.log(str);
}



let fs = require('fs');
let input = fs.readFileSync('/dev/stdin').toString();

solution(input);
```

이건 오랜만이라 그런가 꽤 오래 생각했다. 이런 문제들을 많이 안풀어본 것도 있고, 오랜만이기도 하고

이제부터 다시 시동걸어서 공부해가야겠다.